<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Draggable Geofence with JS Geocoder</title>
  <style>
    html, body, #map { height: 100%; margin: 0; padding: 0; }
    #controls {
      position: absolute; top: 10px; left: 50%;
      transform: translateX(-50%);
      background: #fff; padding: 10px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
      font-family: sans-serif; z-index: 5;
    }
    #results {
      position: absolute; bottom: 0; left: 0; right: 0;
      max-height: 25%; overflow-y: auto;
      background: rgba(255,255,255,0.9);
      list-style: none; margin: 0; padding: 5px 10px;
      font-family: sans-serif; z-index: 5;
    }
    #results li { border-bottom: 1px solid #eee; padding: 4px 0; }
  </style>
</head>
<body>
  <div id="map"></div>
  <div id="controls">
    <label>
      Radius (m):
      <input type="range" id="radiusSlider" min="100" max="5000" step="100" value="1000">
      <span id="radiusValue">1000</span>
    </label>
    <button id="fetchBtn">Fetch Areas</button>
  </div>
  <ul id="results"></ul>

  <script>
    let map, rect, geocoder;
    const center = { lat: 12.9716, lng: 77.5946 };

    // Convert meters → degrees at Bangalore’s latitude
    function metersToLat(m) { return m / 111320; }
    function metersToLng(m, lat) { return m / (111320 * Math.cos(lat * Math.PI/180)); }

    function initMap() {
      map = new google.maps.Map(document.getElementById('map'), {
        center, zoom: 13
      });
      geocoder = new google.maps.Geocoder();  // JS Geocoder service :contentReference[oaicite:6]{index=6}

      // Draggable, editable square
      const dLat = metersToLat(1000), dLng = metersToLng(1000, center.lat);
      rect = new google.maps.Rectangle({
        map, draggable: true, editable: true,
        bounds: {
          north: center.lat + dLat,
          south: center.lat - dLat,
          east:  center.lng + dLng,
          west:  center.lng - dLng
        },
        fillColor: '#FF0000', fillOpacity: 0.2,
        strokeColor: '#FF0000', strokeWeight: 2
      });
    }

    // Slider updates size
    const slider = document.getElementById('radiusSlider'),
          radiusValue = document.getElementById('radiusValue');
    slider.addEventListener('input', () => {
      const m = +slider.value;
      radiusValue.textContent = m;
      const bounds = rect.getBounds(), c = bounds.getCenter();
      const dLat = metersToLat(m), dLng = metersToLng(m, c.lat());
      rect.setBounds({
        north: c.lat() + dLat,
        south: c.lat() - dLat,
        east:  c.lng() + dLng,
        west:  c.lng() - dLng
      });
    });

    // Promisified reverse-geocode at a point :contentReference[oaicite:7]{index=7}
    function geocodePt(latlng) {
      return new Promise((resolve, reject) => {
        geocoder.geocode({ location: latlng }, (results, status) => {
          if (status === 'OK') resolve(results);
          else if (status === 'ZERO_RESULTS') resolve([]);  // allow empty :contentReference[oaicite:8]{index=8}
          else reject(status);
        });
      });
    }

    document.getElementById('fetchBtn').addEventListener('click', async () => {
      const bounds = rect.getBounds();
      const sw = bounds.getSouthWest().toJSON();
      const ne = bounds.getNorthEast().toJSON();
      const rows = 5, cols = 5;
      const latStep = (ne.lat - sw.lat)/(rows-1),
            lngStep = (ne.lng - sw.lng)/(cols-1);
      const names = new Set(), promises = [];

      // Sample grid
      for (let i=0; i<rows; i++) {
        for (let j=0; j<cols; j++) {
          const lat = sw.lat + latStep*i,
                lng = sw.lng + lngStep*j;
          promises.push(
            geocodePt({lat,lng})
              .then(results => {
                results.forEach(r => {
                  r.address_components.forEach(ac => {
                    if (ac.types.includes('locality') ||
                        ac.types.includes('sublocality')) {
                      names.add(ac.long_name);
                    }
                  });
                });
              })
          );
        }
      }

      // Wait, then render
      try {
        await Promise.all(promises);  // aggregate all calls :contentReference[oaicite:9]{index=9}
        const ul = document.getElementById('results');
        ul.innerHTML = '';
        if (!names.size) {
          ul.innerHTML = '<li>No areas found in this box</li>';
        } else {
          names.forEach(n => {
            const li = document.createElement('li');
            li.textContent = n;
            ul.appendChild(li);
          });
        }
      } catch (err) {
        alert('Geocoder error: ' + err);
      }
    });

    // Load the Maps JS API with callback
    window.initMap = initMap;
  </script>
  <script
    src="https://maps.googleapis.com/maps/api/js?key=apikey&callback=initMap"
    async defer>
  </script>
</body>
</html>